index ced1084d78b..d5d5db8ef2a 100644
--- a/src/sys/f90-mod/petscsysmod.F90
+++ b/src/sys/f90-mod/petscsysmod.F90
@@ -352,9 +352,11 @@
           PetscErrorCode             :: ierr
 
           if (filename .ne. PETSC_NULL_CHARACTER) then
-             PetscCall(PetscInitializeF(trim(filename),help,PETSC_TRUE,ierr))
+             call PetscInitializeF(trim(filename),help,PETSC_TRUE,ierr)
+             CHKERRQ(ierr)
           else
-             PetscCall(PetscInitializeF(filename,help,PETSC_TRUE,ierr))
+             call PetscInitializeF(filename,help,PETSC_TRUE,ierr)
+             CHKERRQ(ierr)
           endif
         end subroutine PetscInitializeWithHelp
 
@@ -366,9 +368,11 @@
           PetscErrorCode             :: ierr
 
           if (filename .ne. PETSC_NULL_CHARACTER) then
-             PetscCall(PetscInitializeF(trim(filename),PETSC_NULL_CHARACTER,PETSC_TRUE,ierr))
+             call PetscInitializeF(trim(filename),PETSC_NULL_CHARACTER,PETSC_TRUE,ierr)
+             CHKERRQ(ierr)
           else
-             PetscCall(PetscInitializeF(filename,PETSC_NULL_CHARACTER,PETSC_TRUE,ierr))
+             call PetscInitializeF(filename,PETSC_NULL_CHARACTER,PETSC_TRUE,ierr)
+             CHKERRQ(ierr)
           endif
         end subroutine PetscInitializeNoHelp
 
@@ -378,7 +382,8 @@
         subroutine PetscInitializeNoArguments(ierr)
           PetscErrorCode             :: ierr
 
-          PetscCall(PetscInitializeF(PETSC_NULL_CHARACTER,PETSC_NULL_CHARACTER,PETSC_TRUE,ierr))
+          call PetscInitializeF(PETSC_NULL_CHARACTER,PETSC_NULL_CHARACTER,PETSC_TRUE,ierr)
+          CHKERRQ(ierr)
         end subroutine PetscInitializeNoArguments
         end module
 
index e40f153ac69..955d09b70e4 100644
--- a/src/snes/tutorials/ex5f.F90
+++ b/src/snes/tutorials/ex5f.F90
@@ -72,10 +72,12 @@
 !  Initialize program
 ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
-      PetscCallA(PetscInitialize(ierr))
-      PetscCallMPIA(MPI_Comm_size(PETSC_COMM_WORLD,size,ierr))
-      PetscCallMPIA(MPI_Comm_rank(PETSC_COMM_WORLD,rank,ierr))
-
+      call PetscInitialize(ierr)
+      CHKERRA(ierr)
+      call MPI_Comm_size(PETSC_COMM_WORLD,size,ierr)
+      CHKERRMPIA(ierr)
+      call MPI_Comm_rank(PETSC_COMM_WORLD,rank,ierr)
+      CHKERRMPIA(ierr)
 !  Initialize problem parameters
 
       i1 = 1
@@ -83,7 +85,9 @@
       lambda_max = 6.81
       lambda_min = 0.0
       lambda     = 6.0
-      PetscCallA(PetscOptionsGetReal(PETSC_NULL_OPTIONS,PETSC_NULL_CHARACTER,'-par',lambda,PETSC_NULL_BOOL,ierr))
+      call PetscOptionsGetReal(PETSC_NULL_OPTIONS,PETSC_NULL_CHARACTER,'-par',lambda,PETSC_NULL_BOOL,ierr)
+      CHKERRA(ierr)
+
 ! this statement is split into multiple-lines to keep lines under 132 char limit - required by 'make check'
       if (lambda .ge. lambda_max .or. lambda .le. lambda_min) then
         ierr = PETSC_ERR_ARG_OUTOFRANGE; SETERRA(PETSC_COMM_WORLD,ierr,'Lambda')
@@ -93,13 +97,16 @@
 !  Create nonlinear solver context
 ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
-      PetscCallA(SNESCreate(PETSC_COMM_WORLD,snes,ierr))
+      call SNESCreate(PETSC_COMM_WORLD,snes,ierr)
+      CHKERRA(ierr)
 
 !  Set convergence test routine if desired
 
-      PetscCallA(PetscOptionsHasName(PETSC_NULL_OPTIONS,PETSC_NULL_CHARACTER,'-my_snes_convergence',flg,ierr))
+      call PetscOptionsHasName(PETSC_NULL_OPTIONS,PETSC_NULL_CHARACTER,'-my_snes_convergence',flg,ierr)
+      CHKERRA(ierr)
       if (flg) then
-        PetscCallA(SNESSetConvergenceTest(snes,MySNESConverged,0,PETSC_NULL_FUNCTION,ierr))
+        call SNESSetConvergenceTest(snes,MySNESConverged,0,PETSC_NULL_FUNCTION,ierr)
+        CHKERRA(ierr)
       endif
 
 ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@@ -113,17 +120,22 @@
 #if defined(PETSC_HAVE_FORTRAN_FREE_LINE_LENGTH_NONE)
       PetscCallA(DMDACreate2d(PETSC_COMM_WORLD,DM_BOUNDARY_NONE,DM_BOUNDARY_NONE,DMDA_STENCIL_STAR,i4,i4,PETSC_DECIDE,PETSC_DECIDE,i1,i1,PETSC_NULL_INTEGER,PETSC_NULL_INTEGER,da,ierr))
 #else
-      call DMDACreate2d(PETSC_COMM_WORLD,DM_BOUNDARY_NONE,DM_BOUNDARY_NONE,DMDA_STENCIL_STAR,i4,i4,PETSC_DECIDE,PETSC_DECIDE,i1,i1, &
-                        PETSC_NULL_INTEGER,PETSC_NULL_INTEGER,da,ierr)
+      call DMDACreate2d(PETSC_COMM_WORLD,DM_BOUNDARY_NONE,DM_BOUNDARY_NONE,DMDA_STENCIL_STAR,i4,i4,PETSC_DECIDE,PETSC_DECIDE, &
+                        i1,i1, PETSC_NULL_INTEGER,PETSC_NULL_INTEGER,da,ierr)
+      CHKERRA(ierr)
 #endif
-      PetscCallA(DMSetFromOptions(da,ierr))
-      PetscCallA(DMSetUp(da,ierr))
+      call DMSetFromOptions(da,ierr)
+      CHKERRA(ierr)
+      call DMSetUp(da,ierr)
+      CHKERRA(ierr)
 
 !  Extract global and local vectors from DMDA; then duplicate for remaining
 !  vectors that are the same types
 
-      PetscCallA(DMCreateGlobalVector(da,x,ierr))
-      PetscCallA(VecDuplicate(x,r,ierr))
+      call DMCreateGlobalVector(da,x,ierr)
+      CHKERRA(ierr)
+      call VecDuplicate(x,r,ierr)
+      CHKERRA(ierr)
 
 !  Get local grid boundaries (for 2-dimensional DMDA)
 
@@ -133,9 +145,12 @@
       call DMDAGetInfo(da,PETSC_NULL_INTEGER,mx,my,PETSC_NULL_INTEGER,PETSC_NULL_INTEGER,PETSC_NULL_INTEGER, &
                        PETSC_NULL_INTEGER,PETSC_NULL_INTEGER,PETSC_NULL_INTEGER,PETSC_NULL_INTEGER,PETSC_NULL_INTEGER, &
                        PETSC_NULL_INTEGER,PETSC_NULL_INTEGER,ierr)
+      CHKERRA(ierr)
 #endif
-      PetscCallA(DMDAGetCorners(da,xs,ys,PETSC_NULL_INTEGER,xm,ym,PETSC_NULL_INTEGER,ierr))
-      PetscCallA(DMDAGetGhostCorners(da,gxs,gys,PETSC_NULL_INTEGER,gxm,gym,PETSC_NULL_INTEGER,ierr))
+      call DMDAGetCorners(da,xs,ys,PETSC_NULL_INTEGER,xm,ym,PETSC_NULL_INTEGER,ierr)
+      CHKERRA(ierr)
+      call DMDAGetGhostCorners(da,gxs,gys,PETSC_NULL_INTEGER,gxm,gym,PETSC_NULL_INTEGER,ierr)
+      CHKERRA(ierr)
 
 !  Here we shift the starting indices up by one so that we can easily
 !  use the Fortran convention of 1-based indices (rather 0-based indices).
@@ -152,9 +167,12 @@
 
 !  Set function evaluation routine and vector
 
-      PetscCallA(DMDASNESSetFunctionLocal(da,INSERT_VALUES,FormFunctionLocal,da,ierr))
-      PetscCallA(DMDASNESSetJacobianLocal(da,FormJacobianLocal,da,ierr))
-      PetscCallA(SNESSetDM(snes,da,ierr))
+      call DMDASNESSetFunctionLocal(da,INSERT_VALUES,FormFunctionLocal,da,ierr)
+      CHKERRA(ierr)
+      call DMDASNESSetJacobianLocal(da,FormJacobianLocal,da,ierr)
+      CHKERRA(ierr)
+      call SNESSetDM(snes,da,ierr)
+      CHKERRA(ierr)
 
 ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 !  Customize nonlinear solver; set runtime options
@@ -162,7 +180,8 @@
 
 !  Set runtime options (e.g., -snes_monitor -snes_rtol <rtol> -ksp_type <type>)
 
-          PetscCallA(SNESSetFromOptions(snes,ierr))
+      call SNESSetFromOptions(snes,ierr)
+      CHKERRA(ierr)
 ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 !  Evaluate initial guess; then solve nonlinear system.
 ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@@ -172,9 +191,12 @@
 !  to employ an initial guess of zero, the user should explicitly set
 !  this vector to zero by calling VecSet().
 
-      PetscCallA(FormInitialGuess(x,ierr))
-      PetscCallA(SNESSolve(snes,PETSC_NULL_VEC,x,ierr))
-      PetscCallA(SNESGetIterationNumber(snes,its,ierr))
+      call FormInitialGuess(x,ierr)
+      CHKERRA(ierr)
+      call SNESSolve(snes,PETSC_NULL_VEC,x,ierr)
+      CHKERRA(ierr)
+      call SNESGetIterationNumber(snes,its,ierr)
+      CHKERRA(ierr)
       if (rank .eq. 0) then
          write(6,100) its
       endif
@@ -185,11 +207,16 @@
 !  are no longer needed.
 ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
-      PetscCallA(VecDestroy(x,ierr))
-      PetscCallA(VecDestroy(r,ierr))
-      PetscCallA(SNESDestroy(snes,ierr))
-      PetscCallA(DMDestroy(da,ierr))
-      PetscCallA(PetscFinalize(ierr))
+      call VecDestroy(x,ierr)
+      CHKERRA(ierr)
+      call VecDestroy(r,ierr)
+      CHKERRA(ierr)
+      call SNESDestroy(snes,ierr)
+      CHKERRA(ierr)
+      call DMDestroy(da,ierr)
+      CHKERRA(ierr)
+      call PetscFinalize(ierr)
+      CHKERRA(ierr)
       end
 
 ! ---------------------------------------------------------------------
@@ -231,15 +258,18 @@
 !    - Note that the Fortran interface to VecGetArray() differs from the
 !      C version.  See the users manual for details.
 
-      PetscCall(VecGetArray(X,lx_v,lx_i,ierr))
+      call VecGetArray(X,lx_v,lx_i,ierr)
+      CHKERRQ(ierr)
 
 !  Compute initial guess over the locally owned part of the grid
 
-      PetscCall(InitialGuessLocal(lx_v(lx_i),ierr))
+      call InitialGuessLocal(lx_v(lx_i),ierr)
+      CHKERRQ(ierr)
 
 !  Restore vector
 
-      PetscCall(VecRestoreArray(X,lx_v,lx_i,ierr))
+      call VecRestoreArray(X,lx_v,lx_i,ierr)
+      CHKERRQ(ierr)
 
       return
       end
@@ -357,7 +387,8 @@
  10      continue
  20   continue
 
-      PetscCall(PetscLogFlops(11.0d0*ym*xm,ierr))
+      call PetscLogFlops(11.0d0*ym*xm,ierr)
+      CHKERRQ(ierr)
 
       return
       end
@@ -448,7 +479,8 @@
 !       Some f90 compilers need 4th arg to be of same type in both calls
                col(1) = row
                v(1)   = one
-               PetscCall(MatSetValuesLocal(jac,i1,row,i1,col,v,INSERT_VALUES,ierr))
+               call MatSetValuesLocal(jac,i1,row,i1,col,v,INSERT_VALUES,ierr)
+               CHKERRQ(ierr)
 !           interior grid points
             else
                v(1) = -hxdhy
@@ -461,15 +493,20 @@
                col(3) = row
                col(4) = row + 1
                col(5) = row + gxm
-               PetscCall(MatSetValuesLocal(jac,i1,row,i5,col,v, INSERT_VALUES,ierr))
+               call MatSetValuesLocal(jac,i1,row,i5,col,v, INSERT_VALUES,ierr)
+               CHKERRQ(ierr)
             endif
  10      continue
  20   continue
-      PetscCall(MatAssemblyBegin(jac,MAT_FINAL_ASSEMBLY,ierr))
-      PetscCall(MatAssemblyEnd(jac,MAT_FINAL_ASSEMBLY,ierr))
+      call MatAssemblyBegin(jac,MAT_FINAL_ASSEMBLY,ierr)
+      CHKERRQ(ierr)
+      call MatAssemblyEnd(jac,MAT_FINAL_ASSEMBLY,ierr)
+      CHKERRQ(ierr)
       if (A .ne. jac) then
-         PetscCall(MatAssemblyBegin(A,MAT_FINAL_ASSEMBLY,ierr))
-         PetscCall(MatAssemblyEnd(A,MAT_FINAL_ASSEMBLY,ierr))
+         call MatAssemblyBegin(A,MAT_FINAL_ASSEMBLY,ierr)
+         CHKERRQ(ierr)
+         call MatAssemblyEnd(A,MAT_FINAL_ASSEMBLY,ierr)
+         CHKERRQ(ierr)
       endif
       return
       end
@@ -488,8 +525,10 @@
       Vec f
       PetscErrorCode ierr
 
-      PetscCall(SNESGetFunction(snes,f,PETSC_NULL_FUNCTION,dummy,ierr))
-      PetscCall(VecNorm(f,NORM_INFINITY,nrm,ierr))
+      call SNESGetFunction(snes,f,PETSC_NULL_FUNCTION,dummy,ierr)
+      CHKERRQ(ierr)
+      call VecNorm(f,NORM_INFINITY,nrm,ierr)
+      CHKERRQ(ierr)
       if (nrm .le. 1.e-5) reason = SNES_CONVERGED_FNORM_ABS
 
       end
